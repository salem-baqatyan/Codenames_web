<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Codenames Pro - Game</title>
    <style>
        /* <!-- CSS Section --> */
        /* --- Global & Root --- */

        :root { --bg-color: #0d1117; --blue-glow: 0 0 20px #3498db; --red-glow: 0 0 20px #e74c3c; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { margin: 0; padding: 0; height: 100dvh; overflow: hidden; background-color: #000; font-family: 'Tahoma', sans-serif; }

        /* --- Loading Screen Styles --- */
        #loadingScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 9999;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.1);
            border-left-color: #7ed321; border-radius: 50%; animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Main Wrapper --- */
        .mobile-wrapper {
            width: 100%; max-width: 450px; height: 100dvh; margin: 0 auto; overflow: hidden;
            background-color: var(--bg-color); display: flex; flex-direction: column;
            border-left: 1px solid #333; border-right: 1px solid #333; position: relative;
        }

        /* --- Custom Alert --- */
        .custom-alert { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.7); 
            background: #1a1a1a; border: 2px solid #555; border-radius: 20px; padding: 0; 
            text-align: center; z-index: 10000; color: white; display: none; width: 75%; 
            max-width: 320px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); opacity: 0; 
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s;
            overflow: hidden; user-select: none; -webkit-user-select: none;
        }

        .custom-alert.show-win { 
            display: block; opacity: 1; transform: translate(-50%, -50%) scale(1); 
        }

        .alert-drag-handle {
            height: 35px; width: 100%; cursor: move; 
            display: flex; align-items: center; justify-content: center; 
            background: rgba(255,255,255,0.02);
            touch-action: none; 
        }
        .drag-indicator { width: 35px; height: 4px; background: #444; border-radius: 10px; }

        .alert-win { border-color: #7ed321 !important; }
        .alert-lose { border-color: #e74c3c !important; }
        .alert-body { padding: 10px 20px 20px 20px; font-size: 0.95rem; line-height: 1.5; }
        .alert-btns { display: flex; flex-direction: column; gap: 8px; padding: 0 20px 20px 20px; }
        .alert-btn { 
            padding: 10px; border-radius: 12px; cursor: pointer; border: none; 
            font-weight: bold; font-size: 0.85rem; transition: 0.2s; 
        }
        .alert-btn:active { transform: scale(0.95); }
        .btn-ok { background: linear-gradient(135deg, #7ed321 0%, #417505 100%); color: white; border: 1px solid #b8e986; }
        .btn-cancel { background: #333; color: #bbb; border: 1px solid #444; }

        /* ŸÖÿ§ŸÇÿ™ ÿØÿßÿ¶ÿ±Ÿä ÿ®ÿ≥Ÿäÿ∑ */
.timer-container {
    position: relative;
    width: 60px;
    height: 60px;
    margin: 10px auto;
}
.timer-svg {
    transform: rotate(-90deg);
    width: 60px;
    height: 60px;
}
.timer-circle-bg {
    fill: none;
    stroke: rgba(255, 255, 255, 0.1);
    stroke-width: 4;
}
.timer-circle-fg {
    fill: none;
    stroke: #3498db;
    stroke-width: 4;
    stroke-linecap: round;
    stroke-dasharray: 176; /* ÿßŸÑŸÖÿ≠Ÿäÿ∑ ÿ™ŸÇÿ±Ÿäÿ®ÿßŸã 2 * pi * r */
    stroke-dashoffset: 0;
    transition: stroke-dashoffset 1s linear;
}
#countdown-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-weight: bold;
    color: white;
}
        /* --- Players List Modal & Mini Cards --- */
        #playersListModal {
            position: absolute; top: 60px; right: 15px; left: auto; width: 280px; height: auto;
            background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px; padding: 12px; z-index: 1100; display: none; flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); transform-origin: top right; animation: popIn 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        .players-modal-title { font-size: 0.7rem; font-weight: bold; color: #fff; text-align: right; margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; }
        .horizontal-players-scroll { display: flex; gap: 12px; overflow-x: auto; padding: 5px 2px 10px 2px; scrollbar-width: none; }
        .player-card-mini { display: flex; flex-direction: column; align-items: center; min-width: 50px; position: relative; user-select: none; }
        .player-avatar-mini-wrap { position: relative; width: 44px; height: 44px; }

        .is-admin-mini::after { content: "üëë"; position: absolute; top: -10px; left: -5px; font-size: 1.1rem; transform: rotate(-20deg); z-index: 10; }
        .avatar-frame { width: 100%; height: 100%; border-radius: 50%; display: flex; align-items: center; justify-content: center; padding: 2px; border: 2px solid #fff; background: #333; overflow: hidden; }
        .mini-img { width: 100%; height: 100%; border-radius: 50%; object-fit: cover; }
        .mini-name-tag { margin-top: -6px; font-size: 0.55rem; padding: 1px 7px; border-radius: 5px; color: white; background: rgba(0,0,0,0.8); z-index: 5; white-space: nowrap; border: 1px solid transparent; }

        .player-blue .avatar-frame { background: #1e3a5f !important; }
        .player-red .avatar-frame { background: #7b241c !important; }
        .player-red .avatar-frame { border-color: #e74c3c !important; background: #7b241c !important; }
        .player-spec .avatar-frame { border-color: rgba(255,255,255,0.4) !important; background: #222 !important; }
        .is-me-mini .mini-name-tag { border: 1.5px solid #7ed321 !important; box-shadow: 0 0 5px rgba(126, 211, 33, 0.5); }

        /* --- Top Bar --- */
        .top-bar { display: flex; justify-content: space-between; align-items: center; padding: 10px 10px; flex-shrink: 0; user-select: none; -webkit-user-select: none; }
        .top-left, .top-right { display: flex; gap: 8px; align-items: center; }
        .top-timer { color: white; font-size: 1.5rem; font-weight: 900; font-family: 'Courier New', Courier, monospace; position: absolute; left: 50%; transform: translateX(-50%); text-shadow: 0 0 10px rgba(255, 0, 0, 0.3); }
        .icon-circle { width: 40px; height: 40px; background: rgba(255,255,255,0.1); border-radius: 50%; display: flex; align-items: center; justify-content: center; border: 0.5px solid white; cursor: pointer; color: white; }
        .btn-pill { background: rgba(255,255,255,0.1); border: 1px solid #444; padding: 6px 12px; border-radius: 20px; font-size: 0.75rem; display: flex; align-items: center; gap: 5px; cursor: pointer; color: white; }

        /* --- Dashboard & Teams --- */
        .dashboard { 
            height: 30%; min-height: 160px; display: grid; grid-template-columns: 1fr 1.2fr 1fr; 
            gap: 5px; padding: 0px 10px 10px 10px; flex-shrink: 0; position: relative; 
            transition: background 0.8s ease; background: #0d1117;
        }

        .turn-blue-operative {
            background: radial-gradient(circle at top right, rgba(52, 152, 219, 0.4) 0%, transparent 70%);
        }

        .turn-blue-spymaster {
            background: radial-gradient(circle at bottom right, rgba(52, 152, 219, 0.4) 0%, transparent 70%);
        }

        .turn-red-operative {
            background: radial-gradient(circle at top left, rgba(231, 76, 60, 0.4) 0%, transparent 70%);
        }

        .turn-red-spymaster {
            background: radial-gradient(circle at bottom left, rgba(231, 76, 60, 0.4) 0%, transparent 70%);
        }
        .team-side { display: flex; flex-direction: column; gap: 4px; }
        .player-card { flex: 1; border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 1px solid rgba(255,255,255,0.1); background: #222; transition: 0.3s; position: relative; }
        .blue-team .player-card { background: linear-gradient(135deg, #1e3a5f 0%, #3498db 100%); }
        .red-team .player-card { background: linear-gradient(135deg, #7b241c 0%, #e74c3c 100%); }
        .role-title { position: absolute; top: 3px; font-size: 0.5rem; color: rgba(255,255,255,0.6); font-weight: bold; }
        .avatar-img { width: 35px; height: 35px; border-radius: 50%; border: 2px solid white; object-fit: cover; background: rgba(0,0,0,0.3); }
        .player-name { font-size: 0.55rem; color: white; margin-top: 0px; font-weight: bold; }
        .active-blue { box-shadow: var(--blue-glow); border: 2px solid white !important; }
        .active-red { box-shadow: var(--red-glow); border: 2px solid white !important; }
        .score { font-size: 1.5rem; font-weight: 900; text-align: center; color: white; display: flex; align-items: center; justify-content: center;}

        /* --- Game Log --- */
        .game-log-container { background: #333; border-radius: 10px; border: 1px solid #555; padding: 5px; overflow: hidden; display: flex; flex-direction: column; }
        #log-content { flex: 1; background: #2a2a2a; border-radius: 4px; font-size: 0.6rem; overflow-y: auto; color: white; padding: 5px; display: flex; flex-direction: column-reverse; gap: 8px; scrollbar-width: none; }
        .log-row { display: flex; width: 100%; align-items: center; gap: 5px; }
        .row-blue { justify-content: flex-start; flex-direction: row; } 
        .row-red { justify-content: flex-end; flex-direction: row; } 
        .log-clue-item { display: flex; align-items: center; gap: 4px; border-radius: 5px; padding: 2px 4px; border: 1px solid rgba(255,255,255,0.2); width: 100%; }
        .log-clue-blue { background: #3498db; flex-direction: row; }
        .log-clue-red { background: #e74c3c; flex-direction: row-reverse; }
        .log-avatar { width: 18px; height: 18px; border-radius: 50%; border: 2px solid; }
        .log-text-clue { font-weight: bold; color: black; background: white; border-radius: 3px; padding: 1px 4px; width: 100%; text-align: center; font-size: 0.55rem;}
        .log-num-circle { width: 16px; height: 16px; background: white; border-radius: 50%; color: black; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.55rem; flex-shrink: 0;}
        .log-guess-item { display: flex; align-items: center; gap: 4px; }
        .row-blue .log-guess-item { flex-direction: row; }
        .row-red .log-guess-item { flex-direction: row-reverse; }
        .log-guess-text { padding: 1px 6px; border-radius: 4px; font-weight: bold; color: white; font-size: 0.55rem; }
        .bg-blue { background: #3498db; } .bg-red { background: #e74c3c; } .bg-brown { background: #d2b48c; } .bg-black { background: #000; color: white !important; }

        /* --- Game Grid --- */
        .grid-container { flex: 1; display: grid; grid-template-columns: repeat(5, 1fr); grid-template-rows: repeat(5, 1fr); gap: 4px; padding: 8px; flex-shrink: 0; min-height: 0; }
        .card { height: 100%; width: 100%; border-radius: 5px; padding: 2px; display: flex; cursor: pointer; position: relative; perspective: 1000px; }
        .card-selected { transform: scale(0.95); box-shadow: 0 0 10px #7ed321; }
        .confirm-btn { position: absolute; top: -5px; right: -5px; width: 22px; height: 22px; background: #7ed321; border: 2px solid white; border-radius: 50%; display: none; justify-content: center; align-items: center; z-index: 110; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .confirm-btn svg { width: 14px; height: 14px; fill: white; }

        /* --- Card Visuals & Reveal --- */
        .card-main-body { flex: 1; border-radius: 3px; display: flex; flex-direction: column; border: 1px solid; overflow: hidden; pointer-events: none; position: relative; }
        .bottom-box { margin-top: auto; height: 45%; display: flex; justify-content: center; align-items: center; font-size: 1rem; font-weight: normal; border-top: 1px solid; color: white; }
        .card-blue { background: #3ec1f3; } .card-blue .card-main-body { background: #19a8ff; border-color: #0b4d9b; } .card-blue .bottom-box { background: #0b4d9b; border-color: #3ec1f3; }
        .card-red { background: #ff8e7a; } .card-red .card-main-body { background: #ff6a4c; border-color: #8c2b1e; } .card-red .bottom-box { background: #8c2b1e; border-color: #ff8e7a; }
        .card-black { background: #7a7a7a; } .card-black .card-main-body { background: #444; border-color: #222; } .card-black .bottom-box { background: #1a1a1a; border-color: #7a7a7a; }
        .card-brown { background: #fbe0c3; } .card-brown .card-main-body { background: #f7cda3; border-color: #9a7452; } .card-brown .bottom-box { background: #9a7452; border-color: #fbe0c3; }
        .card-hidden { background: #fbe0c3 !important; } .card-hidden .card-main-body { background: #f7cda3 !important; border-color: #9a7452 !important; } .card-hidden .bottom-box { background: #9a7452 !important; border-color: #fbe0c3 !important; }
        .card-reveal-img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 5; border-radius: 3px; opacity: 0; pointer-events: none; transform: translateY(-100%); transform-origin: top center; transition: transform 1s cubic-bezier(0.4, 0, 0.2, 1); }
        .card-revealed:not(.already-revealed) .card-reveal-img { opacity: 1; pointer-events: auto; animation: pushFromTop 1s ease-out forwards; }
        .already-revealed .card-reveal-img { opacity: 1; pointer-events: auto; transform: translateY(0); }
        @keyframes pushFromTop { 0% { transform: translateY(-100%); opacity: 1; } 100% { transform: translateY(0); opacity: 1; } }
        .card-peeking .card-reveal-img { transform: rotateX(-55deg) translateY(-5px); z-index: 6; box-shadow: 0 15px 30px rgba(0,0,0,0.8); opacity: 1; pointer-events: auto; transition: transform 1s cubic-bezier(0.4, 0, 0.2, 1); }
        .card.card-peeking { overflow: visible !important; z-index: 100 !important; }
        .card-revealed { cursor: default; }

        /* --- Control Panel --- */
        .control-area { height: 65px; background: #222; border-top: 1px solid #444; padding: 5px 15px; display: flex; align-items: center; flex-shrink: 0; }
        .clue-bar-layout { width: 100%; display: flex; align-items: center; gap: 8px; padding: 0 10px;}
        .clue-input-wrapper { flex: 1; background: white; border-radius: 20px; height: 35px; display: flex; align-items: center; padding: 0 12px; }
        .clue-input { width: 100%; border: none; outline: none; font-weight: bold; color: #333; text-align: center; font-size: 0.8rem; background: transparent; }
        .clue-select { width: 45px; height: 35px; border-radius: 50%; border: 2px solid #555; background: white; color: #19a8ff; font-weight: bold; text-align: center; appearance: none; outline: none; font-size: 0.9rem; transition: 0.3s; }
        .send-btn { width: 75px; height: 35px; background: linear-gradient(to bottom, #7ed321, #417505); border: 1.5px solid #b8e986; border-radius: 18px; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 2px 0 #2e5a03;}
        .end-turn-btn { background: linear-gradient(to bottom, #d0021b, #8b0000) !important; }
        .arrow-icon { width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 10px solid white; }
        .x-icon { color: white; font-weight: 900; font-size: 1.2rem; }

        /* --- Utilities --- */
        .disabled-area { opacity: 0.7; pointer-events: none; filter: grayscale(0.5); }
        .error-border { border-color: #ff0000 !important; box-shadow: 0 0 10px #ff0000; }
    </style>
</head>

<body>
<!-- HTML Section -->

<!-- loadingScreen -->
<div id="loadingScreen">
    <div class="spinner"></div>
    <p style="margin-top: 15px; font-size: 0.9rem; color: #888;">ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...</p>
</div>

<!-- App Wrapper -->
<div class="mobile-wrapper">
            <!-- Players List Modal -->
        <div id="playersListModal">
            <div class="players-modal-title">ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ</div>
            <div class="horizontal-players-scroll" id="playersListContainer"> </div>
        </div>
    <!-- Custom Alert Modal -->
    <div id="customAlert" class="custom-alert">
        <p id="alertMsg"></p>
        <div class="alert-btns">
            <button class="alert-btn btn-ok" id="alertOk">ŸÖŸàÿßŸÅŸÇ</button>
            <button class="alert-btn btn-cancel" id="alertCancel">ÿ•ŸÑÿ∫ÿßÿ°</button>
        </div>
    </div>

    <!-- App Bar -->
    <div class="top-bar">
        <div class="top-left">
            <div class="icon-circle" onclick="openPlayersModal()">
                <span id="playerCount" style="font-size:0.8rem;font-weight:bold;margin-left:2px;">0</span> üë§
            </div> 
            <div class="btn-pill" id="roomDisplay" onclick="copyRoomLink()">üîó ÿßŸÑÿ∫ÿ±ŸÅÿ©</div>
        </div>

        <div class="top-timer" id="lobbyDisplayTimer"></div>

        <div class="top-right">
            <div class="icon-circle" onclick="openProfileSettings()">‚öôÔ∏è</div>
        </div>
    </div>

    <!-- Teams Dashboard -->
<div class="dashboard" id="gameDashboard"> 
    <div class="team-side blue-team">
        <div class="player-card" id="blue-operative">
            <span class="role-title">BLUE SIDE</span>
            <div class="avatar-box"></div>
            <div class="player-name">‚Äî</div>
        </div>
        <div class="score" id="blue-score">15</div>
    </div>

    <div class="game-log-container">
        <div style="text-align:center;font-size:0.4rem;color:#aaa;margin-bottom:2px;">CO-OP LOG</div>
        <div id="log-content"></div>
    </div>

        <div class="team-side red-team">
        <div class="player-card" id="red-operative">
            <span class="role-title">RED SIDE</span>
            <div class="avatar-box"></div>
            <div class="player-name">‚Äî</div>
        </div>
        <div class="score" id="red-score">15</div>
    </div>

</div>

    <!-- Game Grid -->
    <div class="grid-container" id="grid"></div>

    <!-- Control Panel -->
    <div class="control-area">
        <div id="clue-ui" class="clue-bar-layout">
            <div class="clue-input-wrapper">
                <input type="text" id="clueInput" class="clue-input" placeholder="ÿßŸÉÿ™ÿ® ÿ™ŸÑŸÖŸäÿ≠">
            </div>
            <select id="clueNum" class="clue-select">
                <option value="-">-</option>
                <option value="0">0</option><option value="1">1</option><option value="2">2</option>
                <option value="3">3</option><option value="4">4</option><option value="5">5</option>
                <option value="6">6</option><option value="7">7</option><option value="‚àû">‚àû</option>
            </select>
        </div>

        <div id="action-btn" class="send-btn" onclick="handleAction()">
            <div id="btn-icon" class="arrow-icon"></div>
        </div>
    </div>

</div>


<script type="module">
// <!-- JS Section -->

/* ---------- 1. Setup & Config ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getDatabase, ref, onValue, get, update, runTransaction, push } 
from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

const firebaseConfig = {
    apiKey: "AIzaSyC95r_D7FVO-cynZ-gK6zbldvvrY4HD2YQ",
    authDomain: "codenames-5fd71.firebaseapp.com",
    databaseURL: "https://codenames-5fd71-default-rtdb.firebaseio.com",
    projectId: "codenames-5fd71",
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const params = new URLSearchParams(window.location.search);
const roomId = params.get("r");
const playerId = params.get("p");

const roomRef = ref(db, `rooms/${roomId}`);
const gameRef = ref(db, `rooms/${roomId}/game`);
const playersRef = ref(db, `rooms/${roomId}/players`);
const statusRef = ref(db, `rooms/${roomId}/status`);
const logRef = ref(db, `rooms/${roomId}/game/log`);
const resultRef = ref(db, `rooms/${roomId}/game/winner`);
const offsetRef = ref(db, ".info/serverTimeOffset");



/* ---------- 2. State & Assets ---------- */
const avatarImages = [
    "img/avatar/snowman.webp",
    "img/avatar/confused_woman.webp",
    "img/avatar/cool_girl.webp",
    "img/avatar/delivery_boy.webp",
    "img/avatar/laughing.webp",
    "img/avatar/old_man.webp",
    "img/avatar/photographer.webp",
    "img/avatar/pizza_guy.webp",
    "img/avatar/reader.webp",
    "img/avatar/surprised_man.webp",
];

const cardVisuals = {
    'blue': Array.from({length: 9}, (_, i) => `img/card/Blue${i + 1}.webp`),
    'red': Array.from({length: 9}, (_, i) => `img/card/Red${i + 1}.webp`),
    'brown': Array.from({length: 9}, (_, i) => `img/card/Normal${i + 1}.webp`),
    'black': ['img/card/Black.webp']
};

// ÿ™ÿ¨ŸÖŸäÿπ ŸÉŸÑ ÿßŸÑÿµŸàÿ± ŸÅŸä ŸÖÿµŸÅŸàŸÅÿ© Ÿàÿßÿ≠ÿØÿ© ŸÑŸÑÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ≥ÿ®ŸÇ
const allImagesToPreload = [
    ...avatarImages,
    ...cardVisuals['blue'],
    ...cardVisuals['red'],
    ...cardVisuals['brown'],
    ...cardVisuals['black']
];

let myRole = null;      
let myTeam = null;      
let isSpy = false;
let isOperative = false;
let isSpectator = false;

let playersCache = {};
let gameState = null;   

let selectedCards = new Set();   
let guessesThisTurn = 0;

let turnStartTime = null; 
let timerDuration = 0;   
let timerInterval = null;
let serverTimeOffset = 0; 
let isPageLoaded = false; 
let peekingCards = new Set(); 
// ŸÖŸäÿ≤ÿ© ŸÑŸÑŸÖÿ¥ÿßŸáÿØ: ÿßŸÑÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™ ÿßŸÑÿ¨ÿßŸÜÿ®Ÿäÿ© Ÿäÿ∫Ÿäÿ± ÿÆÿ±Ÿäÿ∑ÿ™Ÿá
document.getElementById('blue-operative').onclick = () => { if(isSpectator) { myTeam = 'blue'; renderGrid(); } };
document.getElementById('red-operative').onclick = () => { if(isSpectator) { myTeam = 'red'; renderGrid(); } };

/* ---------- 3. Profile Management ---------- */
onValue(offsetRef, (snap) => {
    serverTimeOffset = snap.val() || 0;
});

function startGameManager() {
    const loader = document.getElementById('loadingScreen');
    
    // Ÿàÿ∂ÿπ ŸÖŸáŸÑÿ© ÿ£ŸÇÿµÿßŸáÿß 5 ÿ´ŸàÿßŸÜŸä ŸÑÿ•ÿÆŸÅÿßÿ° ÿßŸÑŸÑŸàÿØÿ± ŸÖŸáŸÖÿß ÿ≠ÿØÿ´ ŸÑÿ∂ŸÖÿßŸÜ ÿπÿØŸÖ ÿ™ŸàŸÇŸÅ ÿßŸÑŸÑÿπÿ®ÿ©
    const forceHideTimeout = setTimeout(() => {
        if (loader.style.display !== 'none') finishLoading();
    }, 5000);

    const finishLoading = () => {
        clearTimeout(forceHideTimeout);
        loader.style.opacity = '0';
        setTimeout(() => {
            loader.style.display = 'none';
            isPageLoaded = true; 
            if (gameState) applyGameStateToUI(); 
        }, 300);
    };

    // ÿ™ŸÜŸÅŸäÿ∞ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ≥ÿ®ŸÇ
    preloadImages().then(finishLoading).catch(finishLoading);
}


/* ---------- 4. Utility Helpers ---------- */
function areImagesCached() {
    for (let src of allImagesToPreload) {
        let img = new Image();
        img.src = src;
        if (!img.complete) return false;
    }
    return true;
}

function preloadImages() {
    const promises = allImagesToPreload.map(src => {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = src;
            img.onload = resolve;
            img.onerror = resolve; 
        });
    });
    return Promise.all(promises);
}

function showCustomAlert(msg, showCancel = false, onOk = null, okText = "ŸÖŸàÿßŸÅŸÇ", cancelText = "ÿ•ŸÑÿ∫ÿßÿ°", onCancel = null) {
    const modal = document.getElementById('customAlert');
    const okBtn = document.getElementById('alertOk');
    const cancelBtn = document.getElementById('alertCancel');
    
    document.getElementById('alertMsg').innerHTML = msg;
    
    modal.style.display = 'block';
    setTimeout(() => modal.classList.add('show-win'), 10); 

    okBtn.innerText = okText;
    okBtn.onclick = () => { 
        modal.classList.remove('show-win');
        setTimeout(() => { modal.style.display = 'none'; if(onOk) onOk(); }, 400);
    };
    
    cancelBtn.style.display = showCancel ? 'block' : 'none';
    cancelBtn.innerText = cancelText;
    cancelBtn.onclick = () => { 
        modal.classList.remove('show-win');
        setTimeout(() => { modal.style.display = 'none'; if(onCancel) onCancel(); }, 400);
    };
}

function makeDraggable(el) {
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    const handle = el.querySelector(".alert-drag-handle");
    let isDragging = false;

    handle.onmousedown = dragStart;
    handle.addEventListener('touchstart', dragStart, { passive: false });

    function dragStart(e) {
        isDragging = true;
        if (e.type === "mousedown") e.preventDefault();
        
        pos3 = e.clientX || e.touches[0].clientX;
        pos4 = e.clientY || e.touches[0].clientY;

        document.onmouseup = dragEnd;
        document.addEventListener('touchend', dragEnd);
        
        document.onmousemove = dragMove;
        document.addEventListener('touchmove', dragMove, { passive: false });
    }

    function dragMove(e) {
        if (!isDragging) return;
        if (e.type === "touchmove") e.preventDefault();

        requestAnimationFrame(() => {
            let x = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            let y = e.clientY || (e.touches ? e.touches[0].clientY : 0);
            
            pos1 = pos3 - x;
            pos2 = pos4 - y;
            pos3 = x;
            pos4 = y;

            el.style.transform = "none"; 
            el.style.margin = "0";
            el.style.top = (el.offsetTop - pos2) + "px";
            el.style.left = (el.offsetLeft - pos1) + "px";
        });
    }

    function dragEnd() {
        isDragging = false;
        document.onmouseup = null;
        document.onmousemove = null;
        document.removeEventListener('touchend', dragEnd);
        document.removeEventListener('touchmove', dragMove);
    }
}

window.copyRoomLink = () => {
    const urlParams = new URLSearchParams(window.location.search);
    const roomCode = urlParams.get('r');

    if (roomCode) {
        const lobbyLink = `${window.location.origin}/lobby.html?r=${roomCode}`;
        
        navigator.clipboard.writeText(lobbyLink);
        showToast("‚úÖ ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ∫ÿ±ŸÅÿ©!");
    } else {
        showToast("‚ùå ÿπÿ∞ÿ±ÿßŸãÿå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ±ŸÖÿ≤ ÿßŸÑÿ∫ÿ±ŸÅÿ©");
    }
};

function showToast(message) {
    const toast = document.createElement("div");
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed;
        bottom: 25px;
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: rgba(20, 20, 20, 0.95);
        color: #ddd;
        padding: 10px 18px;
        border-radius: 14px;
        font-size: 0.75rem;
        font-weight: 600;
        border: 1px solid rgba(52, 152, 219, 0.6);
        box-shadow: 0 8px 20px rgba(0,0,0,.6);
        opacity: 0;
        transition: all .25s ease;
        z-index: 9999;
        pointer-events: none;
        backdrop-filter: blur(6px);
    `;
    document.body.appendChild(toast);
    requestAnimationFrame(() => {
        toast.style.opacity = "1";
        toast.style.transform = "translateX(-50%) translateY(0)";
    });
    setTimeout(() => {
        toast.style.opacity = "0";
        toast.style.transform = "translateX(-50%) translateY(10px)";
        setTimeout(() => toast.remove(), 250);
    }, 1800);
}

function hideLoading() {
    const loader = document.getElementById('loadingScreen');
    loader.style.opacity = '0';
    loader.style.transition = 'opacity 0.4s ease';
    setTimeout(() => loader.style.display = 'none', 400);
}


/* ---------- 5. Lobby & Team Logic ---------- */
document.getElementById('roomDisplay').innerText = "üîó " + roomId;

onValue(playersRef, (snap) => {
    playersCache = snap.val() || {};
    const me = playersCache[playerId];
    if (!me) return;

    // ŸÅŸä ÿßŸÑÿ™ÿπÿßŸàŸÜŸä: ÿßŸÑŸÅÿ±ŸäŸÇ ŸáŸà blue-operative ÿ£Ÿà red-operative ŸÅŸÇÿ∑
    myRole = me.team; 
    myTeam = myRole?.startsWith("blue") ? "blue" : "red";
    
    // ŸÉŸÑÿß ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ŸáŸÖ ŸÇÿßÿØÿ© ŸàŸÖŸÜŸÅÿ∞ŸäŸÜ ŸÅŸä ŸÜŸÅÿ≥ ÿßŸÑŸàŸÇÿ™
    isSpy = true; 
    isOperative = true;
    isSpectator = (myRole === "spectators-list");

    renderPlayersPanel();
});

function renderPlayersPanel() {
    // ŸÅŸä ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿπÿßŸàŸÜŸä ŸÜÿ±ŸÉÿ≤ ÿπŸÑŸâ Operative ŸÑŸÉŸÑ ÿ¨ÿßŸÜÿ®
    const roleIds = ["red-operative", "blue-operative"];
    roleIds.forEach(r => {
        const card = document.getElementById(r);
        const box = card.querySelector(".avatar-box");
        const nameBox = card.querySelector(".player-name");
        
        // ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®Ÿáÿ∞ÿß ÿßŸÑÿ¨ÿßŸÜÿ®
        const player = Object.values(playersCache).find(p => p.team === r);
        
        if (player) {
            box.innerHTML = `<img src="${player.avatar}" class="avatar-img">`;
            nameBox.textContent = player.name || "Player";
        } else {
            box.innerHTML = "";
            nameBox.textContent = "ÿ®ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑÿµÿØŸäŸÇ...";
        }
    });

    // ÿ™ÿ≠ÿØŸäÿ´ ÿπÿØÿØ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑŸÅÿπŸÑŸä ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©
    const countElement = document.getElementById("playerCount");
    if (countElement) {
        countElement.textContent = Object.keys(playersCache).length;
    }
}

function getVisualForColor(color) {
    const type = color === 'killer' ? 'black' : (color === 'neutral' ? 'brown' : color);
    const availablePool = cardVisuals[type];
    
    // ÿ¨ŸÑÿ® ÿßŸÑÿµŸàÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖÿ© ÿ≠ÿßŸÑŸäÿßŸã ŸÖŸÜ ÿßŸÑŸÑŸàÿ≠ÿ© ŸÑŸÖŸÜÿπ ÿßŸÑÿ™ŸÉÿ±ÿßÿ±
    const usedVisuals = Object.values(gameState.board)
        .filter(c => c.revealed && c.visual)
        .map(c => c.visual);

    const unusedOptions = availablePool.filter(src => !usedVisuals.includes(src));
    
    // ÿ•ÿ∞ÿß ÿßÿ≥ÿ™ÿÆÿØŸÖŸÜÿß ŸÉŸÑ ÿßŸÑÿµŸàÿ± (ŸÜÿßÿØÿ± ÿ¨ÿØÿßŸã)ÿå ŸÜÿÆÿ™ÿßÿ± ÿπÿ¥Ÿàÿßÿ¶Ÿä ŸÖŸÜ ÿßŸÑŸÉŸÑÿå Ÿàÿ•ŸÑÿß ŸÜÿÆÿ™ÿßÿ± ŸÖŸÜ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
    const finalPool = unusedOptions.length > 0 ? unusedOptions : availablePool;
    return finalPool[Math.floor(Math.random() * finalPool.length)];
}


/* ---------- 6. Admin & Game Settings ---------- */
function startGlobalTimer(serverStartTime) {
    if (timerInterval) clearInterval(timerInterval);
    const timerDisplay = document.getElementById('lobbyDisplayTimer');
    if (!timerDisplay) return;
    timerDisplay.style.display = 'flex';

    timerInterval = setInterval(() => {
        const nowCorrected = Date.now() + serverTimeOffset;
        const elapsed = Math.floor((nowCorrected - serverStartTime) / 1000);
        let remaining = Math.max(timerDuration - elapsed, 0);

        const mins = Math.floor(remaining / 60);
        const secs = remaining % 60;
        timerDisplay.innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;

        if (remaining <= 0) {
            clearInterval(timerInterval);
            timerDisplay.classList.remove('timer-pulse');
            
            // ÿ™ÿ≠ÿØŸäÿØ ŸáŸÑ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ≠ÿßŸÑŸä ŸáŸà ÿµÿßÿ≠ÿ® ÿßŸÑÿØŸàÿ±ÿü
            const isCluePhase = (gameState.turn.phase === 'clue');
            const activeTeam = isCluePhase ? gameState.turn.side : (gameState.turn.side === 'red' ? 'blue' : 'red');
            const isMyTurn = (myTeam === activeTeam);

            // ÿ•ÿ∞ÿß ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™ Ÿàÿ£ŸÜÿß ÿµÿßÿ≠ÿ® ÿßŸÑÿØŸàÿ±ÿå Ÿäÿ™ŸÖ ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿØŸàÿ± ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã
            if (isMyTurn && isPageLoaded) {
                endTurn(); 
            }
        } 

        if (remaining <= 10 && remaining > 0) {
            timerDisplay.style.color = "#ff4d4d";
            timerDisplay.classList.add('timer-pulse');
        } else {
            timerDisplay.style.color = "white";
            timerDisplay.classList.remove('timer-pulse');
        }
    }, 1000);
}

/* ---------- 7. Game Engine & Start ---------- */
onValue(gameRef, (snap) => {
    const data = snap.val();
    if (!data) return;
    gameState = data;
    applyGameStateToUI();
});

onValue(logRef, (snap) => {
    const logData = snap.val();
    if (logData && gameState) {
        gameState.log = logData; 
        renderLog(); 
    }
});

onValue(statusRef, (snap) => {
    const status = snap.val();
    if (status === "lobby" && isPageLoaded) {
        // ÿ•ÿ∞ÿß ÿ™ÿ∫Ÿäÿ±ÿ™ ÿßŸÑÿ≠ÿßŸÑÿ© ŸÑÿ±ÿØŸáÿ©ÿå ŸÜŸÜÿ™ŸÇŸÑ ŸÅŸàÿ±ÿßŸã
        window.location.href = `lobby.html?r=${roomId}&p=${playerId}`;
    }
});

onValue(resultRef, (snap) => {
    const winner = snap.val();
    if (!winner || !myTeam) return;

    const modal = document.getElementById('customAlert');
    let title = (winner === "win_coop") ? "üèÜ ÿ™ŸÜÿßÿ∫ŸÖ ŸÖÿ∞ŸáŸÑ! üèÜ" : "üíÄ ÿ≠ÿ∏ÿßŸã ÿ£ŸàŸÅÿ±! üíÄ";
    let message = (winner === "win_coop") ? "ŸÜÿ¨ÿ≠ÿ™ŸÖ ŸÅŸä ŸÉÿ¥ŸÅ ÿßŸÑÿ£ŸáÿØÿßŸÅ!" : "ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÖŸáŸÖÿ© ÿ®ŸÑŸÖÿ≥ ÿßŸÑÿ®ÿ∑ÿßŸÇÿ© ÿßŸÑÿ≥ŸàÿØÿßÿ°!";
    let alertClass = (winner === "win_coop") ? "alert-win" : "alert-lose";

    modal.className = `custom-alert ${alertClass}`;
    modal.innerHTML = `
        <div class="alert-drag-handle"><div class="drag-indicator"></div></div>
        <div class="alert-body" style="text-align:center;">
            <span style="font-size:1.4rem; display:block; margin-bottom:10px;">${title}</span>
            <p style="font-size:1rem; margin-bottom:10px;">${message}</p>
            <div class="timer-container">
                <svg class="timer-svg"><circle class="timer-circle-bg" cx="30" cy="30" r="28"></circle>
                <circle id="timer-bar" class="timer-circle-fg" cx="30" cy="30" r="28" style="stroke-dashoffset: 0;"></circle></svg>
                <div id="countdown-text">10</div>
            </div>
            <p style="font-size:0.8rem; opacity:0.8;">ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑÿ±ÿØŸáÿ© ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã...</p>
        </div>
    `;

    modal.style.display = 'block';
    setTimeout(() => { modal.classList.add('show-win'); makeDraggable(modal); }, 10);

    let timeLeft = 10;
    const timerBar = document.getElementById('timer-bar');
    const countdownText = document.getElementById('countdown-text');
    const totalOffset = 176;

    const countdownInterval = setInterval(async () => {
        timeLeft--;
        if (countdownText) countdownText.innerText = timeLeft;
        if (timerBar) {
            timerBar.style.strokeDashoffset = totalOffset - (timeLeft * (totalOffset / 10));
        }

        if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            handleAutoTransition();
        }
    }, 1000);

    async function handleAutoTransition() {
        const playersSnap = await get(playersRef);
        const currentPlayers = playersSnap.val() || {};
        
        if (!currentPlayers[playerId]) return;

        const playerList = Object.values(currentPlayers).sort((a, b) => a.joinedAt - b.joinedAt);
        const isAdmin = (playerList.length > 0 && playerId === playerList[0].id);

        await update(ref(db, `rooms/${roomId}/players/${playerId}`), { 
            team: "spectators-list" 
        });

        if (isAdmin) {
            await update(roomRef, { 
                status: "lobby",
                "game/winner": null 
            });
        }
    }
});

function applyGameStateToUI() {
    if (!gameState) return;
    if (gameState.turn.phase === "clue") {
        selectedCards.clear();
        guessesThisTurn = 0;
        const clueInput = document.getElementById('clueInput');
        if(clueInput) clueInput.value = '';
    }
    
    renderGrid();
    renderLog();
    updateUI();

    get(ref(db, `rooms/${roomId}/settings/timer`)).then((snap) => {
        const seconds = snap.val();
        const timerDisplay = document.getElementById('lobbyDisplayTimer');
        
        if (seconds && seconds > 0) {
            timerDuration = seconds;
            
            const isCluePhase = (gameState.turn.phase === 'clue');
            const activeTeam = isCluePhase ? gameState.turn.side : (gameState.turn.side === 'red' ? 'blue' : 'red');
            const isMyTurn = (myTeam === activeTeam);

            if (isMyTurn && !gameState.turn.ready) {
                update(gameRef, { 
                    "turn/ready": true, 
                    "turn/updatedAt": Date.now() + serverTimeOffset 
                });
            }

            if (gameState.turn.ready && gameState.turn.updatedAt) {
                startGlobalTimer(gameState.turn.updatedAt);
            } else {
                if(timerDisplay) timerDisplay.innerText = "00:00";
            }
        } else {
            if(timerDisplay) timerDisplay.style.display = 'none';
        }
    });
}

function renderGrid() {
    if (!gameState) return;
    const grid = document.getElementById('grid'); 
    const existingRevealed = Array.from(document.querySelectorAll('.card-revealed')).map(el => el.id);
    
    grid.innerHTML = '';

    Object.entries(gameState.board).forEach(([i, card]) => {
        i = Number(i);
        const div = document.createElement('div');
        const cardId = `card-${i}`;

        const myMapColor = (myTeam === 'red') ? card.sideA : card.sideB;
        
        const visualClass =
            myMapColor === "blue" ? "card-blue" :
            myMapColor === "red" ? "card-red" :
            myMapColor === "killer" ? "card-black" : "card-brown";

        const isSelected = selectedCards.has(i);
        const isPeeking = peekingCards.has(i);

        div.id = cardId;
        div.className = `card ${visualClass} ${card.revealed ? 'card-revealed' : ''} ${isSelected ? 'card-selected' : ''} ${isPeeking ? 'card-peeking' : ''}`;
        
        if (card.revealed && existingRevealed.includes(cardId)) div.classList.add('already-revealed');

        div.innerHTML = `
            <div class="confirm-btn" id="confirm-${i}" style="display: ${isSelected ? 'flex' : 'none'}" onclick="event.stopPropagation(); confirmSelection(${i});">
                <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
            </div>
            ${card.revealed ? `<img src="${card.visual}" class="card-reveal-img" onclick="togglePeek(${i}, event)">` : ''}
            <div class="card-main-body">
                <div class="bottom-box">${card.word}</div>
            </div>`;

        div.onclick = () => handleCardSelection(i);
        grid.appendChild(div);
    });
}

window.togglePeek = function(i, event) {
    event.stopPropagation();
    if (!gameState.board[i].revealed) return;
    
    if (peekingCards.has(i)) peekingCards.delete(i);
    else peekingCards.add(i);
    
    renderGrid();
};

function updateUI() {
    if (!gameState) return;
    
    const dashboard = document.getElementById('gameDashboard');
    const redCard = document.getElementById('red-operative');
    const blueCard = document.getElementById('blue-operative');
    
    const controlArea = document.querySelector('.control-area');
    const clueUI = document.getElementById('clue-ui');
    const actionBtn = document.getElementById('action-btn');
    const btnIcon = document.getElementById('btn-icon');
    const input = document.getElementById('clueInput');
    const select = document.getElementById('clueNum');

    redCard.classList.remove('active-red');
    blueCard.classList.remove('active-blue');
    if (controlArea.querySelector('.turn-info')) controlArea.querySelector('.turn-info').remove();

    const isCluePhase = (gameState.turn.phase === 'clue');
    const activeTeam = isCluePhase ? gameState.turn.side : (gameState.turn.side === 'red' ? 'blue' : 'red');
    if (isSpectator) {
        clueUI.style.display = 'none';
        actionBtn.style.display = 'none';
        if (!controlArea.querySelector('.turn-info')) {
            showTurnInfo(controlArea, { team: activeTeam, phase: isCluePhase ? 'spymaster' : 'operative' });
        }
        return; 
    }
    if (activeTeam === 'red') redCard.classList.add('active-red');
    else blueCard.classList.add('active-blue');

    const revealedGoals = Object.values(gameState.board).filter(card => {
    if (!card.revealed) return false;

    const isRedGoal = (card.sideA === 'red' || card.sideB === 'red');
    const isBlueGoal = (card.sideA === 'blue' || card.sideB === 'blue');
    
    return isRedGoal || isBlueGoal;
}).length;

const remainingToWin = 15 - revealedGoals;

document.getElementById('blue-score').innerText = Math.max(0, remainingToWin);
document.getElementById('red-score').innerText = Math.max(0, remainingToWin);
    const isMyTurn = (myTeam === activeTeam);

    clueUI.style.display = 'none';
    actionBtn.style.display = 'none';
    actionBtn.classList.remove('end-turn-btn', 'disabled-area');
    clueUI.classList.remove('disabled-area');

    if (isCluePhase) {
        if (isMyTurn) {
            clueUI.style.display = 'flex';
            actionBtn.style.display = 'flex';
            input.disabled = false;
            select.disabled = false;
            btnIcon.className = 'arrow-icon';
            btnIcon.innerHTML = '';
        } else {
            showTurnInfo(controlArea, { team: activeTeam, phase: 'spymaster' }); 
        }
    } else {
        if (isMyTurn) {
            clueUI.style.display = 'flex'; 
            clueUI.classList.add('disabled-area');
            input.value = gameState.clue.word;
            select.value = gameState.clue.count;
            
            actionBtn.style.display = 'flex';
            actionBtn.classList.add('end-turn-btn');
            btnIcon.className = '';
            btnIcon.innerHTML = '‚úï';
        } else {
            showTurnInfo(controlArea, { team: activeTeam, phase: 'operative' });
        }
    }
}

function showTurnInfo(container, turn) {
    const div = document.createElement('div');
    div.className = 'turn-info';
    div.style.textAlign = 'center';
    div.style.width = '100%';
    div.style.opacity = '0.8';
    div.innerHTML = `<div style="font-size: 0.8rem; color: white; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">ÿßŸÑÿØŸàÿ± ÿßŸÑÿ¢ŸÜ ÿπŸÜÿØ <b>${turn.team === 'blue' ? 'ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ£ÿ≤ÿ±ŸÇüîµ' : 'ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ£ÿ≠ŸÖÿ±üî¥'}</b><br>(${turn.phase === 'spymaster' ? 'ÿØŸàÿ± ÿßŸÑÿ™ŸÑŸÖŸäÿ≠' : 'ÿØŸàÿ± ŸÉÿ¥ŸÅ ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™'})</div>`;
    container.appendChild(div);
}

function renderLog() {
    const logContainer = document.getElementById('log-content');
    if (!logContainer || !gameState || !gameState.log) return;
    const logEntries = Object.values(gameState.log).sort((a, b) => b.at - a.at);
    logContainer.innerHTML = ''; 
    logEntries.forEach(entry => {
        let html = '';
        const isBlue = entry.team === 'blue';
        const rowClass = isBlue ? 'row-blue' : 'row-red';
        if (entry.type === "clue") {
            const clueClass = isBlue ? 'log-clue-blue' : 'log-clue-red';
            html = `<div class="log-row ${rowClass}"><div class="log-clue-item ${clueClass}"><img src="${entry.avatar}" class="log-avatar" style="border-color:#fff"><div class="log-text-clue">${entry.word}</div><div class="log-num-circle">${entry.count}</div></div></div>`;
        } else if (entry.type === "guess") {
            const colorClass = entry.cardColor === 'blue' ? 'bg-blue' : entry.cardColor === 'red' ? 'bg-red' : entry.cardColor === 'black' ? 'bg-black' : 'bg-brown';
            html = `<div class="log-row ${rowClass}"><div class="log-guess-item"><img src="${entry.avatar}" class="log-avatar" style="border-color:${isBlue ? '#3498db':'#e74c3c'}"><div class="log-guess-text ${colorClass}">${entry.word}</div></div></div>`;
        }
        logContainer.insertAdjacentHTML('beforeend', html);
    });
}

window.handleAction = function() {
    if (!gameState || isSpectator) return;
    
    const isCluePhase = (gameState.turn.phase === 'clue');
    const isMyTurn = (myTeam === gameState.turn.side);

    if (isCluePhase) {
        if (!isMyTurn) return;
        sendClue();
    } else {
        if (myTeam === gameState.turn.side) return; 
        if (guessesThisTurn === 0) {
            showCustomAlert("Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ÿÆÿ™ÿßÿ± ÿ®ÿ∑ÿßŸÇÿ© Ÿàÿßÿ≠ÿØÿ© ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ ŸÇÿ®ŸÑ ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿØŸàÿ±!", true, endTurn);
        } else {
            endTurn();
        }
    }
};

async function sendClue() {
    const input = document.getElementById('clueInput');
    const clueValue = input.value.trim();
    const select = document.getElementById('clueNum');
    const inputWrapper = document.querySelector('.clue-input-wrapper');

    if (!clueValue) {
        inputWrapper.classList.add('error-border');
        setTimeout(() => inputWrapper.classList.remove('error-border'), 1000);
        return;
    }

    const onTableWords = Object.values(gameState.board)
        .filter(c => !c.revealed)
        .map(c => c.word.trim().toLowerCase());
        
    const clueWords = clueValue.toLowerCase().split(/\s+/);
    if (clueWords.some(w => onTableWords.includes(w))) {
        showCustomAlert("ÿÆÿ∑ÿ£! ÿßŸÑÿ™ŸÑŸÖŸäÿ≠ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÉŸÑŸÖÿ© ŸÖÿ∑ÿßÿ®ŸÇÿ© ŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸä ÿßŸÑÿ®ÿ∑ÿßŸÇÿßÿ™.");
        return;
    }

    if (select.value === '-') {
        select.classList.add('error-border');
        setTimeout(() => select.classList.remove('error-border'), 1000);
        return;
    }

    const count = select.value === "‚àû" ? 25 : parseInt(select.value);
    const me = playersCache[playerId];

    await update(gameRef, { 
        clue: { word: clueValue, count: select.value },
        turn: { 
            side: gameState.turn.side, 
            phase: "guess",
            ready: false,
            updatedAt: null
        } 
    });

    await push(logRef, { 
        type: "clue", 
        team: myTeam, 
        word: clueValue, 
        count: select.value, 
        avatar: me.avatar, 
        at: Date.now() 
    });
}

window.handleCardSelection = function(i) {
    if (!gameState || isSpectator) return;

    const isMyTurnToGuess = (gameState.turn.phase === 'guess' && myTeam !== gameState.turn.side);
    if (!isMyTurnToGuess || gameState.board[i].revealed) return;

    if (selectedCards.has(i)) {
        selectedCards.delete(i);
    } else {
        selectedCards.add(i);
    }
    renderGrid();
};

window.confirmSelection = async function(i) {
    const isMyTurnToGuess = (gameState.turn.phase === 'guess' && myTeam !== gameState.turn.side);
    if (!gameState || isSpectator || !isMyTurnToGuess || gameState.board[i].revealed || !selectedCards.has(i)) return;
    
    const card = gameState.board[i];
    const me = playersCache[playerId];
    const judgesColor = (gameState.turn.side === 'red') ? card.sideA : card.sideB;

    const updates = {};
    updates[`board/${i}/revealed`] = true;
    
    const chosenVisual = getVisualForColor(judgesColor);
    updates[`board/${i}/visual`] = chosenVisual;

    let nextSide = gameState.turn.side;
    let nextPhase = 'guess';

    if (judgesColor === 'killer') {
        updates.winner = "lose_killer"; 
    } else if (judgesColor === 'neutral') {
        nextSide = (gameState.turn.side === 'red') ? 'blue' : 'red';
        nextPhase = 'clue';
        updates['turn'] = { side: nextSide, phase: nextPhase, ready: false, updatedAt: null };
        updates['clue'] = { word: null, count: null };
        guessesThisTurn = 0;
        selectedCards.clear();
    } else {
        guessesThisTurn++;
        selectedCards.delete(i);
    }

    const revealedGoalsCount = Object.values(gameState.board).filter(c => {
        if (!c.revealed) return false;
        
        const isGoal = (c.sideA === 'blue' || c.sideA === 'red' || c.sideB === 'blue' || c.sideB === 'red');
        
        return isGoal;
    }).length;

    if (revealedGoalsCount >= 15 && updates.winner !== "lose_killer") {
        updates.winner = "win_coop"; 
    }

    await update(gameRef, updates);

    await push(ref(db, `rooms/${roomId}/game/log`), { 
        type: "guess", 
        team: myTeam, 
        word: card.word, 
        cardColor: judgesColor, 
        avatar: me.avatar, 
        at: Date.now() 
    });
};

async function endTurn() {
    if (!gameState) return;
    const nextSide = (gameState.turn.side === 'red') ? 'blue' : 'red';
    
    await update(gameRef, { 
        turn: { 
            side: nextSide, 
            phase: "clue",
            ready: false,
            updatedAt: null
        }, 
        clue: { word: null, count: null } 
    });
    
    guessesThisTurn = 0;
    selectedCards.clear();
    const input = document.getElementById('clueInput');
    const select = document.getElementById('clueNum');
    if(input) input.value = '';
    if(select) select.value = "-";
}

window.openPlayersModal = async () => {
    const modal = document.getElementById('playersListModal');
    if (modal.style.display === 'flex') { modal.style.display = 'none'; return; }
    const playersSnap = await get(playersRef);
    if (!playersSnap.exists()) return;
    const playerList = Object.values(playersSnap.val());
    const adminId = [...playerList].sort((a, b) => a.joinedAt - b.joinedAt)[0]?.id;
    const teamOrder = ['blue-spymaster', 'blue-operative', 'red-spymaster', 'red-operative', 'spectators-list'];
    const sortedPlayers = playerList.sort((a, b) => teamOrder.indexOf(a.team) - teamOrder.indexOf(b.team));
    const container = document.getElementById('playersListContainer');
    container.innerHTML = '';
    sortedPlayers.forEach(p => {
        let teamClass = p.team.includes('blue') ? 'player-blue' : (p.team.includes('red') ? 'player-red' : 'player-spec');
        const isMe = (p.id === playerId), isPlayerAdmin = (p.id === adminId);
        container.insertAdjacentHTML('beforeend', `
            <div class="player-card-mini ${teamClass} ${isMe ? 'is-me-mini' : ''}">
                <div class="player-avatar-mini-wrap ${isPlayerAdmin ? 'is-admin-mini' : ''}">
                    <div class="avatar-frame"><img src="${p.avatar}" class="mini-img"></div>
                </div>
                <div class="mini-name-tag">${p.name} ${isMe ? '(ÿ£ŸÜÿ™)' : ''}</div>
            </div>`);
    });
    modal.style.display = 'flex';
    modal.onclick = (e) => e.stopPropagation();
};

document.addEventListener('click', (e) => {
    const modal = document.getElementById('playersListModal');
    const playerCountBtn = document.getElementById('playerCount')?.parentElement;
    if (modal && modal.style.display === 'flex' && !modal.contains(e.target) && !playerCountBtn?.contains(e.target)) {
        modal.style.display = 'none';
    }
});



/* ---------- Final: Bootstrap ---------- */
startGameManager();

</script>
</body>
</html>
